"use strict";(self.webpackChunkwhg_training_resources=self.webpackChunkwhg_training_resources||[]).push([[7427],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=r,m=h["".concat(l,".").concat(d)]||h[d]||c[d]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9426:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={},l=void 0,p={unversionedId:"programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way",id:"programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way",title:"parsing_gff3_the_low_level_way",description:"A basic python approach",source:"@site/docs/programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way.md",sourceDirName:"programming/programming_with_gene_annotations",slug:"/programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way",draft:!1,editUrl:"https://github.com/whg-training/whg-training-resources/docs/programming/programming_with_gene_annotations/parsing_gff3_the_low_level_way.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Where_next",permalink:"/whg-training-resources/programming/programming_with_gene_annotations/Where_next"},next:{title:"Statistical modelling",permalink:"/whg-training-resources/statistical_modelling/"}},u={},c=[{value:"A basic python approach",id:"a-basic-python-approach",level:2},{value:"Thoughts",id:"thoughts",level:3},{value:"Writing <code>parseGFF3Data()</code>",id:"writing-parsegff3data",level:2}],h={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"a-basic-python-approach"},"A basic python approach"),(0,o.kt)("p",null,"We could certainly start by reading / parsing each line\nof the file, ignoring the complicated relationship-between-record-y bits. That should be easy right? Something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'def readGFF3( filename ):\n    """Read a GFF3-formatted file, output (something)"""\n    # do something\n    pass\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note: ")," If you are not familiar with python syntax, now would be a good time to refresh via any of the available tutorials.\nThe above code defines a function, and currently contains a documentation comment (the ",(0,o.kt)("inlineCode",{parentName:"p"},'"""..."""')," bit) and also a code\ncomment (starting with ",(0,o.kt)("inlineCode",{parentName:"p"},"#"),".). The ",(0,o.kt)("inlineCode",{parentName:"p"},"pass")," is just there to make this a valid python function that does nothing at the\nmoment.  I'll paste equivalents in other languages below."),(0,o.kt)("p",null,"Can you write this? "),(0,o.kt)("p",null,"But hang on... ",(0,o.kt)("em",{parentName:"p"},"Should")," you write this? As the comment indicates, there're already a couple of issues to deal with:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Issue 1.")," What should ",(0,o.kt)("inlineCode",{parentName:"p"},"readGFF3()")," take in as a parameter?"),(0,o.kt)("p",null,"The best way to figure this out is to think about how you will call it from other code. The seemingly obvious choice above is\nto make it take in a filename, so we would call it like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'readGFF3( "/path/to/gff/file.gff" )\n')),(0,o.kt)("p",null,"That'd be ok. But hold on. Our principles say we should write easily testable code. To test the function above, we'd\nhave to first put test data into a file on the filesystem, then pass the path in... too complex! This suggests we\nshould write our function to take in some data instead - let's say, an array of lines of data. So then we can test it\neasily:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'testData = [\n    "##gff-version 3",\n    |#description: test data",\n    "chr1   me  gene    1   1000    .   +   .   ID=my_test_gene;gene_id=my_test_gene.5;gene_type=transcribed_unprocessed_pseudogene;gene_name=DDX11L1;level=2;hgnc_id=HGNC:37102;havana_gene=OTTHUMG00000000961.2",\n    "chr1   me  exon    1   1000    .   +   .   ID=my_test_exon;gene_id=my_test_exon"\n]\nresult = readGFF3( testData )\n# do something to check the result here\n')),(0,o.kt)("p",null,"But hang on - if we're not actually ",(0,o.kt)("em",{parentName:"p"},"reading")," the data (from a file) then the function name is wrong. It is only parsing\nthe data. So we should actually be writing this function instead:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'def parseGFF3Data( data ):\n    """read an array of lines of GFF3-formatted data, output (something)"\n    ...\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Conclusion:")," we shouldn't write ",(0,o.kt)("inlineCode",{parentName:"p"},"readGFF3()"),".  We should write ",(0,o.kt)("inlineCode",{parentName:"p"},"parseGFF3Data()")," instead."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Consideration 2.")," What should ",(0,o.kt)("inlineCode",{parentName:"p"},"parseGFF3Data()")," output?"),(0,o.kt)("p",null,"There are basically two "),(0,o.kt)("p",null,"The 'keep it simple' principle pretty much dictates how we do this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The GFF file is made up of multiple data rows - this says we should return an array (that is, a python ",(0,o.kt)("inlineCode",{parentName:"p"},"list"),") of\nrows.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("a",{parentName:"p",href:"https://m.ensembl.org/info/website/upload/gff3.html"},"GFF spec")," makes it pretty clear that each row has 9\ncolumns.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The first 8 are single values that contain either a string, an integer (",(0,o.kt)("inlineCode",{parentName:"p"},"start"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"stop"),"), or a floating-point number\n(",(0,o.kt)("inlineCode",{parentName:"p"},"score"),"). These map to python datatypes.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The last column (",(0,o.kt)("inlineCode",{parentName:"p"},"attributes"),") is a kind of catch-all that contains key-value pairs. The\nsimplest way to represent a set of key-value pairs in python is a ",(0,o.kt)("inlineCode",{parentName:"p"},"dict"),"."))),(0,o.kt)("p",null,"This suggests the following structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"class GFFRecord:\n    def __init__( self ): # This is a python 'constructor'\n        self.seqid = None\n        self.source = None\n        self.type = None\n        self.start = None\n        self.end = None\n        self.score = None\n        self.strand = none\n        self.phase = None\n        self.attributes = {}  # a python dict\n")),(0,o.kt)("p",null,"And now we can write our function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'def parseGFF3Data( data ):\n    """Given an array of lines of GFF3-formatted data,\n    parses the data and outputs an array of GFFRecord structs."""\n    result = []\n    # fill in result here\n    return result\n')),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note.")," Arguably, an even simpler way is to forget the above class and just return a dict (or even an array, that\nwouldn't have any column names) for each row. I've gone with the above because I think it makes ",(0,o.kt)("em",{parentName:"p"},"using")," the rows\nsimpler (as opposed to parsing them)."),(0,o.kt)("h3",{id:"thoughts"},"Thoughts"),(0,o.kt)("p",null,"We haven't written any code that does anything yet. But a bit of reasoning has led us to code that is better\nthan the code we would have written (or at least the code ",(0,o.kt)("em",{parentName:"p"},"I")," would have written) in a couple of ways:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"parseGFF3Data()")," will be shorter and simpler to write than ",(0,o.kt)("inlineCode",{parentName:"li"},"readGFF3()")," - since it doesn't have to worry about opening files etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"parseGFF3Data()")," is easier to test than ",(0,o.kt)("inlineCode",{parentName:"li"},"readGFF3()"),", since we can pass data directly in."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"parseGFF3Data()")," is arguably easier to understand (because it is better named."),(0,o.kt)("li",{parentName:"ul"},"It's clear what ",(0,o.kt)("inlineCode",{parentName:"li"},"parseGFF3Data()")," is supposed to return.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note.")," It's never that easy in practice, and you probably won't reach the nicely-testable-well-written code first\ntime in a real problem. However, you can get there by rewriting (or 'refactoring') your code each time you visit it\nwith an eye principles like the ones above."),(0,o.kt)("p",null,"We can test it now using our test data above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"testData = [\n    \"##gff-version 3\",\n    \"#description: test data\",\n    \"chr1   me  gene    1   1000    .   +   .   ID=my_test_gene;gene_id=my_test_gene.5;gene_type=transcribed_unprocessed_pseudogene;gene_name=DDX11L1;level=2;hgnc_id=HGNC:37102;havana_gene=OTTHUMG00000000961.2\",\n    \"chr1   me  exon    1   1000    .   +   .   ID=my_test_exon;gene_id=my_test_exon\"\n]\n\nresult = parseGFF3Data( testData )\nassert result.length == 2\nassert result[0].seqid == 'chr1'\nassert result[0].type == 'gene'\nassert result[0].attributes['ID'] == 'my_test_gene'\nassert result[1].attributes['ID'] == 'my_test_exon'\n# ... etc.\n")),(0,o.kt)("p",null,"Go test-driven development!  You can run this code right now, but of course it fails because we haven't written the actual code."),(0,o.kt)("h2",{id:"writing-parsegff3data"},"Writing ",(0,o.kt)("inlineCode",{parentName:"h2"},"parseGFF3Data()")),(0,o.kt)("p",null,"If you follow the same appraoch as above, it's now pretty easy to write ",(0,o.kt)("inlineCode",{parentName:"p"},"parseGFF3Data()"),". The data comes in rows, so\nwe should iterate over them and parse them one by one:"),(0,o.kt)("p",null,'def parseGFF3Data( data ):\n"""Given an array of lines of GFF3-formatted data,\nparses the data and outputs an array of GFFRecord structs."""\nresult = []\nfor line in data:\nresult.append( parseGFF3Record( line ))\nreturn result'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Solved!\n\n\n\nIf you get here\n\nTo make it work, you need to to [write the parseGFF3Data function][Writing_the_parseGFF3Data_function.md].\n")))}d.isMDXComponent=!0}}]);